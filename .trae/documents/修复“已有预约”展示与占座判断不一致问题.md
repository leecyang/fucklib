## 问题诊断
- 展示“当前已有预约”依赖后端 `GET /library/reserve`，由 `LibService.get_reserve_info` 返回数据。
- 判定逻辑位于 `backend/app/services/lib_service.py:221-227, 229-247`：仅当 `status ∈ [1,2,3,4]`、`seat_key` 存在、且 `date` 不早于今天时返回预约，否则返回 `None`，前端因此不显示该模块。
- 现象为：服务端仍认定用户“持有座位”，前端却不显示该模块。最可能原因是某些学校/节点返回的 `reserve.reserve` 中 `status` 仍为活动态，但 `date` 字段缺失或空字符串，导致 `get_reserve_info` 在 `lib_service.py:235-237` 直接返回 `None`，从而前端不显示；而服务端仍按活动态拒绝新的预约。
- 其他调用点：调度器跳过任务也使用了同一判定（`backend/app/scheduler.py:29-34`），因此后端应统一“是否持有当前预约”的判断口径。

## 改动方案
### 后端
- 放宽日期校验：
  - 在 `get_reserve_info` 中，移除“`date` 缺失即判无预约”的分支，仅在能解析出日期且 `res_date < today` 时判为过期；否则以服务端 `status` 为准。
  - 保留 `status ∈ [1,2,3,4]` 与 `seat_key` 存在的约束，避免把已结束（`status==5`）或脏数据误判为在座。
- 提供统一布尔接口（可选）：
  - 新增 `LibService.has_current_reservation()` 封装上述逻辑，并新增 `GET /library/has_reserve` 路由，供前端/调度器使用统一口径；现有调度器也可继续使用 `get_reserve_info`。

### 前端
- `InteractiveReserve.tsx` 已直接使用 `GET /library/reserve` 并以返回非空显示模块，无需改动。模块文案依据 `status` 展示即可。
- 若采用新布尔接口，可在需要时做轻量优化（例如按钮状态），但不是必要项。

## 校验与验证
- 复现：使用存在“`status` 活动、`date` 缺失”的账号调用 `GET /library/reserve`，当前版本返回 `null`；服务端拒绝 `POST /library/reserve`（已有预约）。
- 修改后：`GET /library/reserve` 返回有效对象，前端显示“当前已有预约”，与服务端拒绝行为一致。
- 回归：
  - 旧日预约（`date < today`）仍被过滤，不显示模块。
  - `status==5`（已结束）不显示模块。
  - `seat_key` 缺失仍不显示模块。
- 日志：保留日期解析失败的 `warning`，但不再据此否定预约。

## 影响面与风险
- 仅影响“是否显示已有预约”与调度器跳过逻辑的一致性；不改变预约/取消接口调用。
- 依赖服务端 `status` 的一致语义，符合当前使用约定。

## 交付内容
- 调整 `lib_service.py:get_reserve_info` 的日期判定分支。
- 可选：新增 `has_current_reservation` 方法与 `GET /library/has_reserve` 路由。
- 简单单元测试/本地验证脚本，覆盖日期缺失、日期为今天、日期为过去三类场景。

请确认是否按此方案实施。