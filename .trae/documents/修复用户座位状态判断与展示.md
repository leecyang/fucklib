## 现状与问题定位
- 数据来源：座位与预约状态完全来自外部 GraphQL 接口 `https://wechat.v2.traceint.com/index.php/graphql/`（POST）；本地数据库不存储座位状态。
- 预选座位：通过 `index` 的 `userAuth.oftenseat.list` 获取，在服务层返回为“常用座位”。当前实现位于 `backend/app/services/lib_service.py:142-149`。
- 当前预约：通过 `index` 的 `userAuth.reserve.reserve` 获取，并在服务层进行有效性过滤，代码位于 `backend/app/services/lib_service.py:204-252`，状态枚举注释与过滤在 `222-227` 行。
- 后端接口：
  - `GET /library/reserve` 直接返回 `get_reserve_info()`，入口 `backend/app/routers/library.py:61-66`
  - `GET /library/frequent-seats` 返回预选座位列表，入口 `backend/app/routers/library.py:82-87`
- 前端展示：
  - 交互页将 `seat.status===1` 视为可预约（空位），见 `frontend/src/pages/InteractiveReserve.tsx:158`
  - “当前已有预约”卡片将 `status===3` 显示为“已入座”，其他一律“未签到”，见 `frontend/src/pages/InteractiveReserve.tsx:241`
  - 座位拾取器同样以 `seat.status===1` 判定可预约，见 `frontend/src/components/SeatPicker.tsx:79-88`
- 症结：
  - 预选座位（oftenseat）与实际预约（reserve）在数据含义上已区分，但接口与前端文案没有明确三类状态的统一枚举与字段；“未签到/已签到/预选”未被一致化返回，前端对 `status===2`（已签到）与 `status===4`（暂离）未区分展示。

## 目标
- 明确三类状态并形成统一返回：
  - `pre-selected`：用户静态备选（不影响是否“拥有座位”）
  - `reserved`：已预约未签到（status==1）
  - `checked-in`：已签到/入座/暂离（status∈{2,3,4}）
- 调整“当前已有预约”模块仅显示 `reserved` 与 `checked-in`；预选座位只显示在“我的备选”。
- 修复用户资格判断：仅当存在 `reserved` 或 `checked-in` 时视为“拥有座位”；`pre-selected` 不影响资格。

## 后端改造
- 服务层（LibService）：
  1. 扩展 `get_reserve_info()` 返回统一字段：在现有对象上新增 `selection_status`（取值 `reserved`/`checked-in`），并保留原始 `status`、`lib_id`、`seat_key` 等。
     - 位置：`backend/app/services/lib_service.py:204-252`
     - 规则：
       - `status==1` → `selection_status='reserved'`
       - `status∈{2,3,4}` → `selection_status='checked-in'`
       - 其他或空 → 返回 `None`
  2. 预选座位列表：`get_seat_info()` 将每项补充 `selection_status='pre-selected'`，仅作为展示辅助，仍不参与资格判断。
     - 位置：`backend/app/services/lib_service.py:142-149`
- 路由层（Library Router）：
  1. `/library/reserve`（GET）：返回包含 `selection_status` 的对象；无预约时返回 `null`。
     - 位置：`backend/app/routers/library.py:61-66`
  2. `/library/frequent-seats`（GET）：列表项包含 `selection_status='pre-selected'`。
     - 位置：`backend/app/routers/library.py:82-87`
  3. 可选新增：`/library/seat-state`（GET）统一返回：`{ current: <reserve or null>, frequent: <list>, timestamp }`，便于前端一次性拉取并区分三类状态。

## 前端改造
- 交互预约页（InteractiveReserve）
  1. “当前已有预约”卡片文案细分：
     - `status==1` → 显示“未签到”
     - `status==2` → 显示“已签到”
     - `status==3` → 显示“已入座”
     - `status==4` → 显示“暂离”
     - 位置：`frontend/src/pages/InteractiveReserve.tsx:241`
  2. 明确区块：
     - “我的备选”：展示 `frequent-seats`（已有）并标注“我的备选”。
     - “当前有效预约（待使用/使用中）”：仅在 `selection_status∈{'reserved','checked-in'}` 时显示；不展示 `pre-selected`。
     - “历史预约记录”：保留占位，后续按 API 能力接入。
  3. 保持座位图逻辑：`seat.status===1` 为可预约，见 `frontend/src/pages/InteractiveReserve.tsx:158`；不变。
- 仪表盘（Dashboard）
  - 如有“当前座位”徽标，仅在 `selection_status` 存在时显示；文案使用上述细分。
- API 客户端（client.ts）
  - 类型兼容：在 `getReserveInfo` 响应形态中允许 `selection_status?: 'reserved'|'checked-in'`。

## 资格判断与接口校验
- 拥有座位的判定：后端以 `status∈{1,2,3,4}` 为“拥有座位”，同时提供 `selection_status` 供前端明确分类；`5`（Finished）与空值视为无座。
- 预选座位不影响资格：`/library/frequent-seats` 仅用于展示与快捷预约。
- 响应示例：
  - `/library/reserve`（无座位）：`null`
  - `/library/reserve`（有座位）：`{ token, status, lib_id, seat_key, ..., selection_status: 'reserved'|'checked-in' }`
  - `/library/frequent-seats`：`[{ lib_id, seat_key, info, ..., selection_status: 'pre-selected' }, ...]`

## 测试计划
- 后端单元测试（pytest）：
  - `tests/test_lib_service_reserve_info.py`
    - `status==1` 返回对象且 `selection_status=='reserved'`
    - `status==2/3/4` 返回对象且 `selection_status=='checked-in'`
    - `status==5` 或空 → `None`
  - `tests/test_routes_library.py`
    - `/library/reserve` 在不同模拟 `index` 响应下返回正确分类
    - `/library/frequent-seats` 列表项包含 `selection_status='pre-selected'`
- 前端测试（Jest/RTL）：
  - 交互页在不同 `reserveInfo.status` 下渲染对应文案（未签到/已签到/已入座/暂离）。
- 集成验证：
  - 登录→拉取 `/library/reserve` 与 `/library/frequent-seats`→切换场馆与座位→预约/取消→蓝牙签到→暂离/退座流程，检查文案与资格判断一致。

## 数据迁移
- 本地数据库不存储座位状态，迁移不需要。
- 若后续需要持久化历史记录，建议新增表 `seat_history`（用户、库、座位、日期、原始 `status`、计算 `selection_status`），本次不实施。

## 兼容与风险控制
- 保留原有字段，前端仅增量读取 `selection_status`；旧前端仍可工作。
- 断言 GraphQL 错误统一处理：现有 `_post` 已根据 `errors.code` 做了失效/绑定学号等处理（`backend/app/services/lib_service.py:82-109`）。
- Away（暂离，status==4）归为 `checked-in`，确保业务上仍判定用户拥有座位。

## 实施顺序
1. 后端服务与路由增量改造，返回 `selection_status`。
2. 前端交互页与仪表盘文案与区块调整。
3. 编写并运行后端/前端测试。
4. 联调验证与修正边界情况（时区/日期、空值）。

## 交付物
- 后端：改造后的 `LibService` 与 `library` 路由（含 `selection_status` 字段）。
- 前端：交互页与仪表盘的状态文案与区块调整。
- 测试：后端与前端测试用例与运行报告。

确认后我将按上述步骤实施改造与测试。